<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.8.1" />
<title>shoji.workspace API documentation</title>
<meta name="description" content="Workspaces let you organise collections of data that belong together. Workspaces can be nested,
like folders in a file system â€¦" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>shoji.workspace</code></h1>
</header>
<section id="section-intro">
<p>Workspaces let you organise collections of data that belong together. Workspaces can be nested,
like folders in a file system.</p>
<p>A workspace contains Tensors and Dimensions that form a coherent dataset. Tensors can only use
dimensions that reside in the same workspace, and the implicit constraints imposed by the use
of common dimensions exist only within a single workspace. </p>
<p>A Workspace is a bit like a collection of tables in a relational database, or a collection of
Pandas DataFrames. Each dimension in a workspace corresponds to a table, and each tensor with
that dimension as its first dimension corresponds to a column in the table. However, workspaces
can also contain tensors that link two or more dimensions.</p>
<p>For example, a simple table of samples, with columns for sample ID, name, age and description
could be modelled as follows:</p>
<pre><code class="python">import shoji
db = shoji.connect()
db.cancer_project = shoji.Workspace()  # Create a new workspace
ws = db.cancer_project

ws.samples = shoji.Dimension(shape=None)  # Create a variable-length dimension
ws.SampleID = shoji.Tensor(&quot;uint32&quot;, (&quot;samples&quot;,))  # Create a vector of sample IDs
ws.SampleName = shoji.Tensor(&quot;string&quot;, (&quot;samples&quot;,))  # Create a vector of sample names
ws.Age = shoji.Tensor(&quot;uint32&quot;, (&quot;samples&quot;,))  # Create a vector of ages
ws.Description = shoji.Tensor(&quot;string&quot;, (&quot;samples&quot;,))  # Create a vector of descriptions
</code></pre>
<h2 id="relationships">Relationships</h2>
<p>Relationships between tensors are established through shared dimensions. For example, we can add a
dimension that describes a set of protein measurements, and a 2D tensor that contains protein
measurements for each sample:</p>
<pre><code class="python"># ...continued from above
ws.proteins = shoji.Dimension(shape=10)  # A fixed-length dimension (10 elements)
ws.ProteinName = shoji.Tensor(&quot;string&quot;, (&quot;proteins&quot;,))
ws.ProteinData = shoji.Tensor(&quot;float32&quot;, (&quot;samples&quot;, &quot;proteins&quot;))
</code></pre>
<p>In the above example, <code>ProteinData</code> is a tensor of protein measurements for each sample.
The shape of the tensor is <code>(n_samples, 10)</code>.</p>
<h2 id="constraints">Constraints</h2>
<p>Within a workspace, the tensors that share a dimension are constrained to have the same number of
elements along that dimension. If a dimension is variable-length, elements can be added, but must
be added to all the tensors that share that dimension. Note that elements can be added only along
the first dimension of a tensor.</p>
<p>To add data while enforcing constraints, use the <code>append</code> method on the <code><a title="shoji.dimension.Dimension" href="dimension.html#shoji.dimension.Dimension">Dimension</a></code>.</p>
<h2 id="managing-workspaces">Managing workspaces</h2>
<p>When you connect to the Shoji database, you are connected to the root workspace:</p>
<pre><code class="python">import shoji
db = shoji.connect()  # db is a shoji.Workspace object representing the root
</code></pre>
<p>Workspaces are created by assigning a newly created workspace object to a name on an existing
workspace. This allows you to create nested workspaces:</p>
<pre><code class="python">db.scRNA = shoji.Workspace()
db.scRNA.analysis_20200601 = shoji.Workspace()  # Create a sub-workspace
</code></pre>
<p>You can delete a workspace using the <code>del</code> statement:</p>
<pre><code class="python">del db.scRNA
</code></pre>
<p><strong>WARNING</strong>: Deleting a workspace takes effect immediately and without confirmation. All sub-workspaces and all tensors and dimensions that they contain are deleted. The action cannot be undone.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
Workspaces let you organise collections of data that belong together. Workspaces can be nested,
like folders in a file system.

A workspace contains Tensors and Dimensions that form a coherent dataset. Tensors can only use
dimensions that reside in the same workspace, and the implicit constraints imposed by the use
of common dimensions exist only within a single workspace. 

A Workspace is a bit like a collection of tables in a relational database, or a collection of
Pandas DataFrames. Each dimension in a workspace corresponds to a table, and each tensor with
that dimension as its first dimension corresponds to a column in the table. However, workspaces
can also contain tensors that link two or more dimensions.

For example, a simple table of samples, with columns for sample ID, name, age and description
could be modelled as follows:

```python
import shoji
db = shoji.connect()
db.cancer_project = shoji.Workspace()  # Create a new workspace
ws = db.cancer_project

ws.samples = shoji.Dimension(shape=None)  # Create a variable-length dimension
ws.SampleID = shoji.Tensor(&#34;uint32&#34;, (&#34;samples&#34;,))  # Create a vector of sample IDs
ws.SampleName = shoji.Tensor(&#34;string&#34;, (&#34;samples&#34;,))  # Create a vector of sample names
ws.Age = shoji.Tensor(&#34;uint32&#34;, (&#34;samples&#34;,))  # Create a vector of ages
ws.Description = shoji.Tensor(&#34;string&#34;, (&#34;samples&#34;,))  # Create a vector of descriptions
```

## Relationships

Relationships between tensors are established through shared dimensions. For example, we can add a
dimension that describes a set of protein measurements, and a 2D tensor that contains protein
measurements for each sample:

```python
# ...continued from above
ws.proteins = shoji.Dimension(shape=10)  # A fixed-length dimension (10 elements)
ws.ProteinName = shoji.Tensor(&#34;string&#34;, (&#34;proteins&#34;,))
ws.ProteinData = shoji.Tensor(&#34;float32&#34;, (&#34;samples&#34;, &#34;proteins&#34;))
```

In the above example, `ProteinData` is a tensor of protein measurements for each sample.
The shape of the tensor is `(n_samples, 10)`.

## Constraints

Within a workspace, the tensors that share a dimension are constrained to have the same number of
elements along that dimension. If a dimension is variable-length, elements can be added, but must
be added to all the tensors that share that dimension. Note that elements can be added only along
the first dimension of a tensor.

To add data while enforcing constraints, use the `append` method on the `shoji.dimension.Dimension`.

## Managing workspaces

When you connect to the Shoji database, you are connected to the root workspace:

```python
import shoji
db = shoji.connect()  # db is a shoji.Workspace object representing the root
```

Workspaces are created by assigning a newly created workspace object to a name on an existing
workspace. This allows you to create nested workspaces:

```python
db.scRNA = shoji.Workspace()
db.scRNA.analysis_20200601 = shoji.Workspace()  # Create a sub-workspace
```

You can delete a workspace using the `del` statement:

```python
del db.scRNA
```

**WARNING**: Deleting a workspace takes effect immediately and without confirmation. All sub-workspaces and all tensors and dimensions that they contain are deleted. The action cannot be undone.
&#34;&#34;&#34;
from typing import Any, Tuple, Union, List
import fdb
import logging
from tqdm import trange
import loompy
import shoji


class Workspace:
        &#34;&#34;&#34;
        Class representing a new Workspace. Use this to create new workspaces in Shoji.
        &#34;&#34;&#34;
        def __init__(self) -&gt; None:
                pass


class WorkspaceManager:
        &#34;&#34;&#34;
        Class for managing workspaces. You should not create WorkspaceManager objects yourself.
        &#34;&#34;&#34;
        def __init__(self, db: fdb.impl.Database, subspace: fdb.directory_impl.DirectorySubspace, path: Union[Tuple, Tuple[str, ...]]) -&gt; None:
                self._db = db
                self._subspace = subspace
                self._path = path
                self._name: str = &#34;&#34;

        def _move_to(self, new_path: Union[str, Tuple[str]]) -&gt; None:
                if not isinstance(new_path, tuple):
                        new_path = (new_path,)
                self._subspace = self._subspace._move_to(self._db.transaction, (&#34;shoji&#34;,) + new_path)
                self._path = new_path
                
        def _create(self, path: Union[str, Tuple[str]]) -&gt; &#34;WorkspaceManager&#34;:
                if not isinstance(path, tuple):
                        path = (path,)
                subspace = self._subspace.create(self._db.transaction, path)
                return WorkspaceManager(self._db.transaction, subspace, self._path + path)

        def _workspaces(self) -&gt; List[str]:
                return self._subspace.list(self._db.transaction)

        def _dimensions(self) -&gt; List[str]:
                return [self._subspace[&#34;dimensions&#34;].unpack(k.key)[0] for k in self._db.transaction[self._subspace[&#34;dimensions&#34;].range()]]

        def _tensors(self) -&gt; List[str]:
                return [self._subspace[&#34;tensors&#34;].unpack(k.key)[0] for k in self._db.transaction[self._subspace[&#34;tensors&#34;].range()]]

        def __dir__(self) -&gt; List[str]:
                dimensions = [self._subspace[&#34;dimensions&#34;].unpack(k)[0] for k,v in self._db.transaction[self._subspace[&#34;dimensions&#34;].range()]]
                tensors = [self._subspace[&#34;tensors&#34;].unpack(k)[0] for k,v in self._db.transaction[self._subspace[&#34;tensors&#34;].range()]]
                return self._subspace.list(self._db.transaction) + dimensions + tensors + object.__dir__(self)

        def __iter__(self):
                for s in self._subspace.list(self._db.transaction):
                        yield self[s]
                dimensions = [self._subspace[&#34;dimensions&#34;].unpack(k)[0] for k,v in self._db.transaction[self._subspace[&#34;dimensions&#34;].range()]]
                for d in dimensions:
                        yield self[d]
                tensors = [self._subspace[&#34;tensors&#34;].unpack(k)[0] for k,v in self._db.transaction[self._subspace[&#34;tensors&#34;].range()]]
                for t in tensors:
                        yield self[t]

        def __contains__(self, name: str) -&gt; bool:
                return shoji.io.get_entity(self._db.transaction, self, name) is not None

        def __getattr__(self, name: str) -&gt; Union[&#34;WorkspaceManager&#34;, shoji.Dimension, shoji.Tensor]:
                if name.startswith(&#34;__&#34;):  # Jupyter calls this method with name = &#34;__wrapped__&#34; and we want to avoid a futile database roundtrip
                        return super().__getattribute__(name)
                result = shoji.io.get_entity(self._db.transaction, self, name)
                if result is None:
                        return super().__getattribute__(name)
                else:
                        return result

        def __getitem__(self, expr: Union[str, &#34;shoji.Filter&#34;, slice]) -&gt; Union[&#34;WorkspaceManager&#34;, shoji.Dimension, &#34;shoji.View&#34;, shoji.Tensor]:
                # Try to read an attribute on the object
                if isinstance(expr, str):
                        return self.__getattr__(expr)
                # Perhaps it&#39;s a view already (e.g. a slice of a dimension)
                if isinstance(expr, shoji.View):
                        return expr
                # Maybe it&#39;s a Filter, or a tuple of Filters?
                if isinstance(expr, shoji.Filter):
                        return shoji.View(self, (expr,))
                elif isinstance(expr, tuple) and isinstance(expr[0], shoji.Filter):
                        return shoji.View(self, expr)
                # Or a slice?
                if isinstance(expr, slice):
                        if expr.start is None and expr.stop is None:
                                return shoji.View(self, ())
                        else:
                                raise KeyError(&#34;Cannot slice workspace directly (use a slice on a dimension instead)&#34;)
                raise KeyError(f&#34;Invalid key &#39;{expr}&#39; (only filter expression or : allowed)&#34;)

        def __setattr__(self, name: str, value: Any) -&gt; None:
                if isinstance(value, Workspace):
                        self._create(name)
                elif isinstance(value, shoji.Dimension):
                        # Check that the first letter is lowercase
                        if not name[0].islower():
                                raise AttributeError(&#34;Dimension name must begin with a lowercase letter&#34;)
                        shoji.io.create_or_update_dimension(self._db.transaction, self, name, value)
                elif isinstance(value, shoji.Tensor):
                        tensor = value
                        # Check that the first letter is uppercase
                        if not name[0].isupper():
                                raise AttributeError(&#34;Tensor name must begin with an uppercase letter&#34;)

                        # Note, this can fail as follows:
                        #  * Before anything has been written
                        #  * After the tensor has been full created but no values have been written
                        #  * After one or more rows have been fully written (consistent with other tensors in the dimension)
                        #  * After all rows have been fully written
                        # In each case, the database state will be consistent
                        shoji.io.create_or_update_tensor(self._db.transaction, self, name, tensor)
                        if tensor.inits is not None:
                                dim = None
                                if tensor.rank &gt; 0 and isinstance(tensor.dims[0], str):
                                        dim = shoji.io.get_dimension(self._db.transaction, self, tensor.dims[0])
                                        if dim is not None:
                                                # This ensures that all dimension constraints are properly checked
                                                shoji.io.append_tensors(self._db.transaction, self, tensor.dims[0], {name: tensor.inits})
                                                return
                                shoji.io.write_tensor_values(self._db.transaction, self, name, tensor)
                else:
                        super().__setattr__(name, value)
        
        def __setitem__(self, name: str, value: Any) -&gt; None:
                self.__setattr__(name, value)

        def __delattr__(self, name: str) -&gt; None:
                shoji.io.delete_entity(self._db.transaction, self, name)

        def __delitem__(self, name: str) -&gt; None:
                shoji.io.delete_entity(self._db.transaction, self, name)

        def from_loom(self, f: str, layers: List[str] = None) -&gt; None:
                with loompy.connect(f, validate=False) as ds:
                        if layers is None:
                                layers = list(ds.layers.keys())
                        self.genes = shoji.Dimension(shape=None)
                        self.cells = shoji.Dimension(shape=None)

                        STEP = 2000
                        logging.info(&#34;Loading row attributes&#34;)
                        for i in trange(0, ds.shape[0], STEP):
                                d = {}
                                for key, vals in ds.ra.items():
                                        dtype = vals.dtype.name
                                        name = key[0].upper() + key[1:]
                                        d[name] = ds.ra[key][i:i + STEP]
                                        if i == 0:
                                                dims = (&#34;genes&#34;, ) + (None,) * (vals.ndim - 1)
                                                self[name] = shoji.Tensor(&#34;string&#34; if dtype == &#34;object&#34; else dtype, dims=dims)
                                self.genes.append(d)

                        self.genes = shoji.Dimension(shape=ds.shape[0])  # Set to a fixed shape to avoid jagged arrays below
                        
                        skipped = [x for x in ds.ca.keys() if x in ds.ra.keys()]
                        for key, vals in ds.ca.items():
                                dtype = ds.ca[key].dtype.name
                                name = key[0].upper() + key[1:]
                                dims = (&#34;cells&#34;, ) + (None,) * (vals.ndim - 1)
                                if name in skipped:
                                        logging.warning(f&#34;Column attribute &#39;{name}&#39; skipped because a row attribute already exists with that name.&#34;)
                                        skipped.append(name)
                                else:
                                        self[name] = shoji.Tensor(&#34;string&#34; if dtype == &#34;object&#34; else dtype, dims=dims)

                        logging.info(&#34;Loading column attributes and matrix layers&#34;)
                        STEP = 200
                        for i in trange(0, ds.shape[1], STEP):
                                d = {}
                                for key in ds.ca.keys():
                                        name = key[0].upper() + key[1:]
                                        if name in skipped:
                                                continue
                                        d[name] = ds.ca[key][i:i + STEP]
                                for key in layers:
                                        if key not in ds.layers:
                                                raise KeyError(f&#34;Layer &#39;{key}&#39; not found&#34;)
                                        if key == &#34;&#34;:
                                                name = &#34;Expression&#34;
                                        else:
                                                name = key[0].upper() + key[1:]
                                        dtype = ds.layers[key].dtype.name
                                        if i == 0:
                                                self[name] = shoji.Tensor(&#34;string&#34; if dtype == &#34;object&#34; else dtype, (&#34;cells&#34;, &#34;genes&#34;))
                                        d[name] = ds.layers[key][:, i:i + STEP].T
                                self.cells.append(d)
                        
        def __repr__(self) -&gt; str:
                subspaces = self._subspace.list(self._db.transaction)
                dimensions = [self._subspace[&#34;dimensions&#34;].unpack(k.key)[0] for k in self._db.transaction[self._subspace[&#34;dimensions&#34;].range()]]
                tensors = [self._subspace[&#34;tensors&#34;].unpack(k.key)[0] for k in self._db.transaction[self._subspace[&#34;tensors&#34;].range()]]
                s = f&#34;Workspace with {len(subspaces)} subspaces, {len(dimensions)} dimensions and {len(tensors)} tensors:&#34;
                for sub in subspaces:
                        s += f&#34;\n  {sub} &lt;Workspace&gt;&#34; 
                for dname in dimensions:
                        s += f&#34;\n  {dname} {self[dname]}&#34;
                for tname in tensors:
                        s += f&#34;\n  {tname} {self[tname]}&#34;
                return s

        def _repr_html_(self):
                if len(self._path) == 0:
                        s = f&#34;&lt;h4&gt;(root) (shoji.Workspace)&lt;/h4&gt;&#34;
                else:
                        s = f&#34;&lt;h4&gt;{self._name} (shoji.Workspace)&lt;/h4&gt;&#34;
                
                subspaces = self._workspaces()
                if len(subspaces) &gt; 0:
                        s += f&#34;&lt;h5&gt;Sub-workspaces&lt;/h5&gt;&#34;
                        s += &#34;&lt;table&gt;&lt;tr&gt;&lt;th&gt;&lt;/th&gt;&lt;th&gt;Contents&lt;/th&gt;&lt;/tr&gt;&#34;
                        for wsname in subspaces:
                                ws = self[wsname]
                                s += &#34;&lt;tr&gt;&#34;
                                n_subspaces = len(ws._workspaces())
                                n_dimensions = len(ws._dimensions())
                                n_tensors = len(ws._tensors())
                                s += f&#34;&lt;td align=&#39;left&#39;&gt;&lt;strong&gt;{ws._name}&lt;/strong&gt;&lt;/td&gt;&lt;td&gt;{n_subspaces} workspaces, {n_dimensions} dimensions, {n_tensors} tensors&lt;/td&gt;&#34;
                                s += &#34;&lt;/tr&gt;&#34;
                        s += &#34;&lt;/table&gt;&#34;
        
                dimensions = self._dimensions()
                if len(dimensions) &gt; 0:
                        s += f&#34;&lt;h5&gt;Dimensions&lt;/h5&gt;&#34;
                        s += &#34;&lt;table&gt;&lt;tr&gt;&lt;th&gt;&lt;/th&gt;&lt;th&gt;shape&lt;/th&gt;&lt;th&gt;length&lt;/th&gt;&lt;/tr&gt;&#34;
                        for dname in dimensions:
                                dim = self[dname]
                                s += &#34;&lt;tr&gt;&#34;
                                s += f&#34;&lt;td align=&#39;left&#39;&gt;&lt;strong&gt;{dim.name}&lt;/strong&gt;&lt;/td&gt;&#34;
                                s += f&#34;&lt;td&gt;{dim.shape:,}&lt;/td&gt;&#34; if dim.shape is not None else &#34;&lt;td&gt;None&lt;/td&gt;&#34;
                                s += f&#34;&lt;td&gt;{dim.length:,}&lt;/td&gt;&#34;
                                s += &#34;&lt;/tr&gt;&#34;
                        s += &#34;&lt;/table&gt;&#34;

                tensors = self._tensors()
                if len(tensors) &gt; 0:
                        s += f&#34;&lt;h5&gt;Tensors&lt;/h5&gt;&#34;
                        s += &#34;&lt;table&gt;&lt;tr&gt;&lt;th&gt;&lt;/th&gt;&lt;th&gt;dtype&lt;/th&gt;&lt;th&gt;rank&lt;/th&gt;&lt;th&gt;dims&lt;/th&gt;&lt;th&gt;shape&lt;/th&gt;&lt;th&gt;(values)&lt;/th&gt;&lt;/tr&gt;&#34;
                        for tname in tensors:
                                t = self[tname]
                                s += &#34;&lt;tr&gt;&#34;
                                s += f&#34;&lt;td align=&#39;left&#39;&gt;&lt;strong&gt;{t.name}&lt;/strong&gt;&lt;/td&gt;&#34;
                                s += f&#34;&lt;td align=&#39;left&#39;&gt;{t.dtype}&lt;/td&gt;&#34;
                                s += f&#34;&lt;td align=&#39;left&#39;&gt;{t.rank}&lt;/td&gt;&#34;
                                if t.rank &gt; 0:
                                        s += &#34;&lt;td&gt;&#34; + &#34; âœ• &#34;.join([str(s) for s in t.dims]) + &#34;&lt;/td&gt;&#34;
                                        s += &#34;&lt;td&gt;&#34; + &#34; âœ• &#34;.join([&#39;{:,}&#39;.format(s) for s in t.shape]) + &#34;&lt;/td&gt;&#34;
                                else:
                                        s += &#34;&lt;td&gt;()&lt;/td&gt;&#34;
                                        s += &#34;&lt;td&gt;(scalar)&lt;/td&gt;&#34;
                                s += f&#34;&lt;td&gt;{t._quick_look()}&lt;/td&gt;&#34;
                                s += &#34;&lt;/tr&gt;&#34;
                        s += &#34;&lt;/table&gt;&#34;
                return s</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="shoji.workspace.Workspace"><code class="flex name class">
<span>class <span class="ident">Workspace</span></span>
</code></dt>
<dd>
<div class="desc"><p>Class representing a new Workspace. Use this to create new workspaces in Shoji.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Workspace:
        &#34;&#34;&#34;
        Class representing a new Workspace. Use this to create new workspaces in Shoji.
        &#34;&#34;&#34;
        def __init__(self) -&gt; None:
                pass</code></pre>
</details>
</dd>
<dt id="shoji.workspace.WorkspaceManager"><code class="flex name class">
<span>class <span class="ident">WorkspaceManager</span></span>
<span>(</span><span>db:Â fdb.impl.Database, subspace:Â fdb.directory_impl.DirectorySubspace, path:Â Union[Tuple,Â Tuple[str,Â ...]])</span>
</code></dt>
<dd>
<div class="desc"><p>Class for managing workspaces. You should not create WorkspaceManager objects yourself.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class WorkspaceManager:
        &#34;&#34;&#34;
        Class for managing workspaces. You should not create WorkspaceManager objects yourself.
        &#34;&#34;&#34;
        def __init__(self, db: fdb.impl.Database, subspace: fdb.directory_impl.DirectorySubspace, path: Union[Tuple, Tuple[str, ...]]) -&gt; None:
                self._db = db
                self._subspace = subspace
                self._path = path
                self._name: str = &#34;&#34;

        def _move_to(self, new_path: Union[str, Tuple[str]]) -&gt; None:
                if not isinstance(new_path, tuple):
                        new_path = (new_path,)
                self._subspace = self._subspace._move_to(self._db.transaction, (&#34;shoji&#34;,) + new_path)
                self._path = new_path
                
        def _create(self, path: Union[str, Tuple[str]]) -&gt; &#34;WorkspaceManager&#34;:
                if not isinstance(path, tuple):
                        path = (path,)
                subspace = self._subspace.create(self._db.transaction, path)
                return WorkspaceManager(self._db.transaction, subspace, self._path + path)

        def _workspaces(self) -&gt; List[str]:
                return self._subspace.list(self._db.transaction)

        def _dimensions(self) -&gt; List[str]:
                return [self._subspace[&#34;dimensions&#34;].unpack(k.key)[0] for k in self._db.transaction[self._subspace[&#34;dimensions&#34;].range()]]

        def _tensors(self) -&gt; List[str]:
                return [self._subspace[&#34;tensors&#34;].unpack(k.key)[0] for k in self._db.transaction[self._subspace[&#34;tensors&#34;].range()]]

        def __dir__(self) -&gt; List[str]:
                dimensions = [self._subspace[&#34;dimensions&#34;].unpack(k)[0] for k,v in self._db.transaction[self._subspace[&#34;dimensions&#34;].range()]]
                tensors = [self._subspace[&#34;tensors&#34;].unpack(k)[0] for k,v in self._db.transaction[self._subspace[&#34;tensors&#34;].range()]]
                return self._subspace.list(self._db.transaction) + dimensions + tensors + object.__dir__(self)

        def __iter__(self):
                for s in self._subspace.list(self._db.transaction):
                        yield self[s]
                dimensions = [self._subspace[&#34;dimensions&#34;].unpack(k)[0] for k,v in self._db.transaction[self._subspace[&#34;dimensions&#34;].range()]]
                for d in dimensions:
                        yield self[d]
                tensors = [self._subspace[&#34;tensors&#34;].unpack(k)[0] for k,v in self._db.transaction[self._subspace[&#34;tensors&#34;].range()]]
                for t in tensors:
                        yield self[t]

        def __contains__(self, name: str) -&gt; bool:
                return shoji.io.get_entity(self._db.transaction, self, name) is not None

        def __getattr__(self, name: str) -&gt; Union[&#34;WorkspaceManager&#34;, shoji.Dimension, shoji.Tensor]:
                if name.startswith(&#34;__&#34;):  # Jupyter calls this method with name = &#34;__wrapped__&#34; and we want to avoid a futile database roundtrip
                        return super().__getattribute__(name)
                result = shoji.io.get_entity(self._db.transaction, self, name)
                if result is None:
                        return super().__getattribute__(name)
                else:
                        return result

        def __getitem__(self, expr: Union[str, &#34;shoji.Filter&#34;, slice]) -&gt; Union[&#34;WorkspaceManager&#34;, shoji.Dimension, &#34;shoji.View&#34;, shoji.Tensor]:
                # Try to read an attribute on the object
                if isinstance(expr, str):
                        return self.__getattr__(expr)
                # Perhaps it&#39;s a view already (e.g. a slice of a dimension)
                if isinstance(expr, shoji.View):
                        return expr
                # Maybe it&#39;s a Filter, or a tuple of Filters?
                if isinstance(expr, shoji.Filter):
                        return shoji.View(self, (expr,))
                elif isinstance(expr, tuple) and isinstance(expr[0], shoji.Filter):
                        return shoji.View(self, expr)
                # Or a slice?
                if isinstance(expr, slice):
                        if expr.start is None and expr.stop is None:
                                return shoji.View(self, ())
                        else:
                                raise KeyError(&#34;Cannot slice workspace directly (use a slice on a dimension instead)&#34;)
                raise KeyError(f&#34;Invalid key &#39;{expr}&#39; (only filter expression or : allowed)&#34;)

        def __setattr__(self, name: str, value: Any) -&gt; None:
                if isinstance(value, Workspace):
                        self._create(name)
                elif isinstance(value, shoji.Dimension):
                        # Check that the first letter is lowercase
                        if not name[0].islower():
                                raise AttributeError(&#34;Dimension name must begin with a lowercase letter&#34;)
                        shoji.io.create_or_update_dimension(self._db.transaction, self, name, value)
                elif isinstance(value, shoji.Tensor):
                        tensor = value
                        # Check that the first letter is uppercase
                        if not name[0].isupper():
                                raise AttributeError(&#34;Tensor name must begin with an uppercase letter&#34;)

                        # Note, this can fail as follows:
                        #  * Before anything has been written
                        #  * After the tensor has been full created but no values have been written
                        #  * After one or more rows have been fully written (consistent with other tensors in the dimension)
                        #  * After all rows have been fully written
                        # In each case, the database state will be consistent
                        shoji.io.create_or_update_tensor(self._db.transaction, self, name, tensor)
                        if tensor.inits is not None:
                                dim = None
                                if tensor.rank &gt; 0 and isinstance(tensor.dims[0], str):
                                        dim = shoji.io.get_dimension(self._db.transaction, self, tensor.dims[0])
                                        if dim is not None:
                                                # This ensures that all dimension constraints are properly checked
                                                shoji.io.append_tensors(self._db.transaction, self, tensor.dims[0], {name: tensor.inits})
                                                return
                                shoji.io.write_tensor_values(self._db.transaction, self, name, tensor)
                else:
                        super().__setattr__(name, value)
        
        def __setitem__(self, name: str, value: Any) -&gt; None:
                self.__setattr__(name, value)

        def __delattr__(self, name: str) -&gt; None:
                shoji.io.delete_entity(self._db.transaction, self, name)

        def __delitem__(self, name: str) -&gt; None:
                shoji.io.delete_entity(self._db.transaction, self, name)

        def from_loom(self, f: str, layers: List[str] = None) -&gt; None:
                with loompy.connect(f, validate=False) as ds:
                        if layers is None:
                                layers = list(ds.layers.keys())
                        self.genes = shoji.Dimension(shape=None)
                        self.cells = shoji.Dimension(shape=None)

                        STEP = 2000
                        logging.info(&#34;Loading row attributes&#34;)
                        for i in trange(0, ds.shape[0], STEP):
                                d = {}
                                for key, vals in ds.ra.items():
                                        dtype = vals.dtype.name
                                        name = key[0].upper() + key[1:]
                                        d[name] = ds.ra[key][i:i + STEP]
                                        if i == 0:
                                                dims = (&#34;genes&#34;, ) + (None,) * (vals.ndim - 1)
                                                self[name] = shoji.Tensor(&#34;string&#34; if dtype == &#34;object&#34; else dtype, dims=dims)
                                self.genes.append(d)

                        self.genes = shoji.Dimension(shape=ds.shape[0])  # Set to a fixed shape to avoid jagged arrays below
                        
                        skipped = [x for x in ds.ca.keys() if x in ds.ra.keys()]
                        for key, vals in ds.ca.items():
                                dtype = ds.ca[key].dtype.name
                                name = key[0].upper() + key[1:]
                                dims = (&#34;cells&#34;, ) + (None,) * (vals.ndim - 1)
                                if name in skipped:
                                        logging.warning(f&#34;Column attribute &#39;{name}&#39; skipped because a row attribute already exists with that name.&#34;)
                                        skipped.append(name)
                                else:
                                        self[name] = shoji.Tensor(&#34;string&#34; if dtype == &#34;object&#34; else dtype, dims=dims)

                        logging.info(&#34;Loading column attributes and matrix layers&#34;)
                        STEP = 200
                        for i in trange(0, ds.shape[1], STEP):
                                d = {}
                                for key in ds.ca.keys():
                                        name = key[0].upper() + key[1:]
                                        if name in skipped:
                                                continue
                                        d[name] = ds.ca[key][i:i + STEP]
                                for key in layers:
                                        if key not in ds.layers:
                                                raise KeyError(f&#34;Layer &#39;{key}&#39; not found&#34;)
                                        if key == &#34;&#34;:
                                                name = &#34;Expression&#34;
                                        else:
                                                name = key[0].upper() + key[1:]
                                        dtype = ds.layers[key].dtype.name
                                        if i == 0:
                                                self[name] = shoji.Tensor(&#34;string&#34; if dtype == &#34;object&#34; else dtype, (&#34;cells&#34;, &#34;genes&#34;))
                                        d[name] = ds.layers[key][:, i:i + STEP].T
                                self.cells.append(d)
                        
        def __repr__(self) -&gt; str:
                subspaces = self._subspace.list(self._db.transaction)
                dimensions = [self._subspace[&#34;dimensions&#34;].unpack(k.key)[0] for k in self._db.transaction[self._subspace[&#34;dimensions&#34;].range()]]
                tensors = [self._subspace[&#34;tensors&#34;].unpack(k.key)[0] for k in self._db.transaction[self._subspace[&#34;tensors&#34;].range()]]
                s = f&#34;Workspace with {len(subspaces)} subspaces, {len(dimensions)} dimensions and {len(tensors)} tensors:&#34;
                for sub in subspaces:
                        s += f&#34;\n  {sub} &lt;Workspace&gt;&#34; 
                for dname in dimensions:
                        s += f&#34;\n  {dname} {self[dname]}&#34;
                for tname in tensors:
                        s += f&#34;\n  {tname} {self[tname]}&#34;
                return s

        def _repr_html_(self):
                if len(self._path) == 0:
                        s = f&#34;&lt;h4&gt;(root) (shoji.Workspace)&lt;/h4&gt;&#34;
                else:
                        s = f&#34;&lt;h4&gt;{self._name} (shoji.Workspace)&lt;/h4&gt;&#34;
                
                subspaces = self._workspaces()
                if len(subspaces) &gt; 0:
                        s += f&#34;&lt;h5&gt;Sub-workspaces&lt;/h5&gt;&#34;
                        s += &#34;&lt;table&gt;&lt;tr&gt;&lt;th&gt;&lt;/th&gt;&lt;th&gt;Contents&lt;/th&gt;&lt;/tr&gt;&#34;
                        for wsname in subspaces:
                                ws = self[wsname]
                                s += &#34;&lt;tr&gt;&#34;
                                n_subspaces = len(ws._workspaces())
                                n_dimensions = len(ws._dimensions())
                                n_tensors = len(ws._tensors())
                                s += f&#34;&lt;td align=&#39;left&#39;&gt;&lt;strong&gt;{ws._name}&lt;/strong&gt;&lt;/td&gt;&lt;td&gt;{n_subspaces} workspaces, {n_dimensions} dimensions, {n_tensors} tensors&lt;/td&gt;&#34;
                                s += &#34;&lt;/tr&gt;&#34;
                        s += &#34;&lt;/table&gt;&#34;
        
                dimensions = self._dimensions()
                if len(dimensions) &gt; 0:
                        s += f&#34;&lt;h5&gt;Dimensions&lt;/h5&gt;&#34;
                        s += &#34;&lt;table&gt;&lt;tr&gt;&lt;th&gt;&lt;/th&gt;&lt;th&gt;shape&lt;/th&gt;&lt;th&gt;length&lt;/th&gt;&lt;/tr&gt;&#34;
                        for dname in dimensions:
                                dim = self[dname]
                                s += &#34;&lt;tr&gt;&#34;
                                s += f&#34;&lt;td align=&#39;left&#39;&gt;&lt;strong&gt;{dim.name}&lt;/strong&gt;&lt;/td&gt;&#34;
                                s += f&#34;&lt;td&gt;{dim.shape:,}&lt;/td&gt;&#34; if dim.shape is not None else &#34;&lt;td&gt;None&lt;/td&gt;&#34;
                                s += f&#34;&lt;td&gt;{dim.length:,}&lt;/td&gt;&#34;
                                s += &#34;&lt;/tr&gt;&#34;
                        s += &#34;&lt;/table&gt;&#34;

                tensors = self._tensors()
                if len(tensors) &gt; 0:
                        s += f&#34;&lt;h5&gt;Tensors&lt;/h5&gt;&#34;
                        s += &#34;&lt;table&gt;&lt;tr&gt;&lt;th&gt;&lt;/th&gt;&lt;th&gt;dtype&lt;/th&gt;&lt;th&gt;rank&lt;/th&gt;&lt;th&gt;dims&lt;/th&gt;&lt;th&gt;shape&lt;/th&gt;&lt;th&gt;(values)&lt;/th&gt;&lt;/tr&gt;&#34;
                        for tname in tensors:
                                t = self[tname]
                                s += &#34;&lt;tr&gt;&#34;
                                s += f&#34;&lt;td align=&#39;left&#39;&gt;&lt;strong&gt;{t.name}&lt;/strong&gt;&lt;/td&gt;&#34;
                                s += f&#34;&lt;td align=&#39;left&#39;&gt;{t.dtype}&lt;/td&gt;&#34;
                                s += f&#34;&lt;td align=&#39;left&#39;&gt;{t.rank}&lt;/td&gt;&#34;
                                if t.rank &gt; 0:
                                        s += &#34;&lt;td&gt;&#34; + &#34; âœ• &#34;.join([str(s) for s in t.dims]) + &#34;&lt;/td&gt;&#34;
                                        s += &#34;&lt;td&gt;&#34; + &#34; âœ• &#34;.join([&#39;{:,}&#39;.format(s) for s in t.shape]) + &#34;&lt;/td&gt;&#34;
                                else:
                                        s += &#34;&lt;td&gt;()&lt;/td&gt;&#34;
                                        s += &#34;&lt;td&gt;(scalar)&lt;/td&gt;&#34;
                                s += f&#34;&lt;td&gt;{t._quick_look()}&lt;/td&gt;&#34;
                                s += &#34;&lt;/tr&gt;&#34;
                        s += &#34;&lt;/table&gt;&#34;
                return s</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="shoji.workspace.WorkspaceManager.from_loom"><code class="name flex">
<span>def <span class="ident">from_loom</span></span>(<span>self, f:Â str, layers:Â List[str]Â =Â None) ->Â NoneType</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def from_loom(self, f: str, layers: List[str] = None) -&gt; None:
        with loompy.connect(f, validate=False) as ds:
                if layers is None:
                        layers = list(ds.layers.keys())
                self.genes = shoji.Dimension(shape=None)
                self.cells = shoji.Dimension(shape=None)

                STEP = 2000
                logging.info(&#34;Loading row attributes&#34;)
                for i in trange(0, ds.shape[0], STEP):
                        d = {}
                        for key, vals in ds.ra.items():
                                dtype = vals.dtype.name
                                name = key[0].upper() + key[1:]
                                d[name] = ds.ra[key][i:i + STEP]
                                if i == 0:
                                        dims = (&#34;genes&#34;, ) + (None,) * (vals.ndim - 1)
                                        self[name] = shoji.Tensor(&#34;string&#34; if dtype == &#34;object&#34; else dtype, dims=dims)
                        self.genes.append(d)

                self.genes = shoji.Dimension(shape=ds.shape[0])  # Set to a fixed shape to avoid jagged arrays below
                
                skipped = [x for x in ds.ca.keys() if x in ds.ra.keys()]
                for key, vals in ds.ca.items():
                        dtype = ds.ca[key].dtype.name
                        name = key[0].upper() + key[1:]
                        dims = (&#34;cells&#34;, ) + (None,) * (vals.ndim - 1)
                        if name in skipped:
                                logging.warning(f&#34;Column attribute &#39;{name}&#39; skipped because a row attribute already exists with that name.&#34;)
                                skipped.append(name)
                        else:
                                self[name] = shoji.Tensor(&#34;string&#34; if dtype == &#34;object&#34; else dtype, dims=dims)

                logging.info(&#34;Loading column attributes and matrix layers&#34;)
                STEP = 200
                for i in trange(0, ds.shape[1], STEP):
                        d = {}
                        for key in ds.ca.keys():
                                name = key[0].upper() + key[1:]
                                if name in skipped:
                                        continue
                                d[name] = ds.ca[key][i:i + STEP]
                        for key in layers:
                                if key not in ds.layers:
                                        raise KeyError(f&#34;Layer &#39;{key}&#39; not found&#34;)
                                if key == &#34;&#34;:
                                        name = &#34;Expression&#34;
                                else:
                                        name = key[0].upper() + key[1:]
                                dtype = ds.layers[key].dtype.name
                                if i == 0:
                                        self[name] = shoji.Tensor(&#34;string&#34; if dtype == &#34;object&#34; else dtype, (&#34;cells&#34;, &#34;genes&#34;))
                                d[name] = ds.layers[key][:, i:i + STEP].T
                        self.cells.append(d)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul>
<li><a href="#relationships">Relationships</a></li>
<li><a href="#constraints">Constraints</a></li>
<li><a href="#managing-workspaces">Managing workspaces</a></li>
</ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="shoji" href="index.html">shoji</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="shoji.workspace.Workspace" href="#shoji.workspace.Workspace">Workspace</a></code></h4>
</li>
<li>
<h4><code><a title="shoji.workspace.WorkspaceManager" href="#shoji.workspace.WorkspaceManager">WorkspaceManager</a></code></h4>
<ul class="">
<li><code><a title="shoji.workspace.WorkspaceManager.from_loom" href="#shoji.workspace.WorkspaceManager.from_loom">from_loom</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.8.1</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>