<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.8.4" />
<title>shoji.workspace API documentation</title>
<meta name="description" content="Workspaces let you organise collections of data that belong together. Workspaces can be nested,
like folders in a file system …" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/highlight.min.js" integrity="sha256-eOgo0OtLL4cdq7RdwRUiGKLX9XsIJ7nGhWEKbohmVAQ=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>shoji.workspace</code></h1>
</header>
<section id="section-intro">
<p>Workspaces let you organise collections of data that belong together. Workspaces can be nested,
like folders in a file system.</p>
<p>A workspace contains Tensors and Dimensions that form a coherent dataset. Tensors can only use
dimensions that reside in the same workspace, and the implicit constraints imposed by the use
of common dimensions exist only within a single workspace. </p>
<p>A Workspace is a bit like a collection of tables in a relational database, or a collection of
Pandas DataFrames. Each dimension in a workspace corresponds to a table, and each tensor with
that dimension as its first dimension corresponds to a column in the table. However, workspaces
can also contain tensors that link two or more dimensions.</p>
<p>For example, a simple table of samples, with columns for sample ID, name, age and description
could be modelled as follows:</p>
<pre><code class="python">import shoji
db = shoji.connect()
db.cancer_project = shoji.Workspace()  # Create a new workspace
ws = db.cancer_project

ws.samples = shoji.Dimension(shape=None)  # Create a variable-length dimension
ws.SampleID = shoji.Tensor(&quot;uint32&quot;, (&quot;samples&quot;,))  # Create a vector of sample IDs
ws.SampleName = shoji.Tensor(&quot;string&quot;, (&quot;samples&quot;,))  # Create a vector of sample names
ws.Age = shoji.Tensor(&quot;uint32&quot;, (&quot;samples&quot;,))  # Create a vector of ages
ws.Description = shoji.Tensor(&quot;string&quot;, (&quot;samples&quot;,))  # Create a vector of descriptions
</code></pre>
<h2 id="relationships">Relationships</h2>
<p>Relationships between tensors are established through shared dimensions. For example, we can add a
dimension that describes a set of protein measurements, and a 2D tensor that contains protein
measurements for each sample:</p>
<pre><code class="python"># ...continued from above
ws.proteins = shoji.Dimension(shape=10)  # A fixed-length dimension (10 elements)
ws.ProteinName = shoji.Tensor(&quot;string&quot;, (&quot;proteins&quot;,))
ws.ProteinData = shoji.Tensor(&quot;float32&quot;, (&quot;samples&quot;, &quot;proteins&quot;))
</code></pre>
<p>In the above example, <code>ProteinData</code> is a tensor of protein measurements for each sample.
The shape of the tensor is <code>(n_samples, 10)</code>.</p>
<h2 id="constraints">Constraints</h2>
<p>Within a workspace, the tensors that share a dimension are constrained to have the same number of
elements along that dimension. If a dimension is variable-length, elements can be added, but must
be added to all the tensors that share that dimension. Note that elements can be added only along
the first dimension of a tensor.</p>
<p>To add data while enforcing constraints, use the <code>append</code> method on the <code><a title="shoji.dimension.Dimension" href="dimension.html#shoji.dimension.Dimension">Dimension</a></code>.</p>
<h2 id="managing-workspaces">Managing workspaces</h2>
<p>When you connect to the Shoji database, you are connected to the root workspace:</p>
<pre><code class="python">import shoji
db = shoji.connect()  # db is a shoji.Workspace object representing the root
</code></pre>
<p>Workspaces are created by assigning a newly created workspace object to a name on an existing
workspace. This allows you to create nested workspaces:</p>
<pre><code class="python">db.scRNA = shoji.Workspace()
db.scRNA.analysis_20200601 = shoji.Workspace()  # Create a sub-workspace
</code></pre>
<p>You can also use brackets to create a workspace with a name defined by an expression:</p>
<pre><code class="python">name = &quot;Hello&quot; + &quot;World&quot;
db[name] = shoji.Workspace()
</code></pre>
<p>You can list workspaces and check for the existence of a workspace in the usual ways:</p>
<pre><code class="python">for ws in db:
        ... # do something with the workspace object

if &quot;samples&quot; in db:
        ... # the workspace existed
</code></pre>
<p>You can list the contents of a workspace:</p>
<pre><code class="python">ws._workspaces()  # Returns a list of names of sub-workspaces
ws._tensors()     # Returns a list of names of tensors in the workspace
ws._dimensions()  # Returns a list of names of dimensions in the workspace
</code></pre>
<p>You can delete a workspace using the <code>del</code> statement:</p>
<pre><code class="python">del db.scRNA
</code></pre>
<p><strong>WARNING</strong>: Deleting a workspace takes effect immediately and without confirmation. All sub-workspaces and all tensors and dimensions that they contain are deleted. The action cannot be undone.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
Workspaces let you organise collections of data that belong together. Workspaces can be nested,
like folders in a file system.

A workspace contains Tensors and Dimensions that form a coherent dataset. Tensors can only use
dimensions that reside in the same workspace, and the implicit constraints imposed by the use
of common dimensions exist only within a single workspace. 

A Workspace is a bit like a collection of tables in a relational database, or a collection of
Pandas DataFrames. Each dimension in a workspace corresponds to a table, and each tensor with
that dimension as its first dimension corresponds to a column in the table. However, workspaces
can also contain tensors that link two or more dimensions.

For example, a simple table of samples, with columns for sample ID, name, age and description
could be modelled as follows:

```python
import shoji
db = shoji.connect()
db.cancer_project = shoji.Workspace()  # Create a new workspace
ws = db.cancer_project

ws.samples = shoji.Dimension(shape=None)  # Create a variable-length dimension
ws.SampleID = shoji.Tensor(&#34;uint32&#34;, (&#34;samples&#34;,))  # Create a vector of sample IDs
ws.SampleName = shoji.Tensor(&#34;string&#34;, (&#34;samples&#34;,))  # Create a vector of sample names
ws.Age = shoji.Tensor(&#34;uint32&#34;, (&#34;samples&#34;,))  # Create a vector of ages
ws.Description = shoji.Tensor(&#34;string&#34;, (&#34;samples&#34;,))  # Create a vector of descriptions
```

## Relationships

Relationships between tensors are established through shared dimensions. For example, we can add a
dimension that describes a set of protein measurements, and a 2D tensor that contains protein
measurements for each sample:

```python
# ...continued from above
ws.proteins = shoji.Dimension(shape=10)  # A fixed-length dimension (10 elements)
ws.ProteinName = shoji.Tensor(&#34;string&#34;, (&#34;proteins&#34;,))
ws.ProteinData = shoji.Tensor(&#34;float32&#34;, (&#34;samples&#34;, &#34;proteins&#34;))
```

In the above example, `ProteinData` is a tensor of protein measurements for each sample.
The shape of the tensor is `(n_samples, 10)`.

## Constraints

Within a workspace, the tensors that share a dimension are constrained to have the same number of
elements along that dimension. If a dimension is variable-length, elements can be added, but must
be added to all the tensors that share that dimension. Note that elements can be added only along
the first dimension of a tensor.

To add data while enforcing constraints, use the `append` method on the `shoji.dimension.Dimension`.

## Managing workspaces

When you connect to the Shoji database, you are connected to the root workspace:

```python
import shoji
db = shoji.connect()  # db is a shoji.Workspace object representing the root
```

Workspaces are created by assigning a newly created workspace object to a name on an existing
workspace. This allows you to create nested workspaces:

```python
db.scRNA = shoji.Workspace()
db.scRNA.analysis_20200601 = shoji.Workspace()  # Create a sub-workspace
```

You can also use brackets to create a workspace with a name defined by an expression:

```python
name = &#34;Hello&#34; + &#34;World&#34;
db[name] = shoji.Workspace()
```

You can list workspaces and check for the existence of a workspace in the usual ways:

```python
for ws in db:
        ... # do something with the workspace object

if &#34;samples&#34; in db:
        ... # the workspace existed
```

You can list the contents of a workspace:

```python
ws._workspaces()  # Returns a list of names of sub-workspaces
ws._tensors()     # Returns a list of names of tensors in the workspace
ws._dimensions()  # Returns a list of names of dimensions in the workspace
```

You can delete a workspace using the `del` statement:

```python
del db.scRNA
```

**WARNING**: Deleting a workspace takes effect immediately and without confirmation. All sub-workspaces and all tensors and dimensions that they contain are deleted. The action cannot be undone.
&#34;&#34;&#34;
from typing import Any, Tuple, Union, List, Dict
import fdb
import os
import numpy as np
import logging
import loompy
import shoji
import shoji.io
from shoji.io import Compartment
import h5py
import pickle
from codecs import decode,encode
from tqdm import trange

        
class Workspace:
        &#34;&#34;&#34;
        Class representing a new Workspace. Use this to create new workspaces in Shoji.
        &#34;&#34;&#34;
        def __init__(self) -&gt; None:
                pass


class WorkspaceManager:
        &#34;&#34;&#34;
        Class for managing workspaces. You should not create WorkspaceManager objects yourself.
        &#34;&#34;&#34;
        def __init__(self, db: fdb.impl.Database, subdir: fdb.directory_impl.DirectorySubspace, path: Union[Tuple, Tuple[str, ...]]) -&gt; None:
                self._db = db
                self._subdir = subdir
                self._path = path
                self._name: str = &#34;&#34;

        def _move_to(self, new_path: Union[str, Tuple[str, ...]]) -&gt; None:
                if isinstance(new_path, str):
                        new_path = tuple(new_path.split(&#34;.&#34;))
                self._subdir = self._subdir.move_to(self._db.transaction, (&#34;shoji&#34;,) + new_path)
                self._path = new_path
                
        def _create(self, path: Union[str, Tuple[str, ...]]) -&gt; &#34;WorkspaceManager&#34;:
                if not isinstance(path, tuple):
                        path = (path,)
                if self._subdir.exists(self._db.transaction, path):
                        raise IOError(f&#34;Workspace &#39;{&#39;/&#39;.join(path)}&#39; already exists&#34;)
                subdir = self._subdir.create(self._db.transaction, path)
                return WorkspaceManager(self._db.transaction, subdir, self._path + path)

        def _workspaces(self) -&gt; List[str]:
                return self._subdir.list(self._db.transaction)

        def _get_workspace(self, name: str) -&gt; &#34;WorkspaceManager&#34;:
                ws = self[name]
                assert isinstance(ws, shoji.WorkspaceManager), f&#34;&#39;{name}&#39; is not a workspace&#34;
                return ws

        def _dimensions(self) -&gt; List[str]:
                return [self._subdir[Compartment.Dimensions].unpack(k.key)[0] for k in self._db.transaction[self._subdir[Compartment.Dimensions].range()]]

        def _get_dimension(self, name: str) -&gt; shoji.Dimension:
                dim = self[name]
                assert isinstance(dim, shoji.Dimension), f&#34;&#39;{name}&#39; is not a dimension&#34;
                return dim

        def _tensors(self, include_not_ready: bool = False) -&gt; List[str]:
                names = [self._subdir[Compartment.Tensors].unpack(k.key)[0] for k in self._db.transaction[self._subdir[Compartment.Tensors].range()]]
                if include_not_ready:
                        return names
                return [name for name in names if shoji.io.get_tensor(self._db.transaction, self, name) is not None]

        def _get_tensor(self, name: str, include_initializing: bool = False) -&gt; shoji.Tensor:
                tensor = shoji.io.get_tensor(self._db.transaction, self, name, include_initializing=include_initializing)
                assert isinstance(tensor, shoji.Tensor), f&#34;&#39;{name}&#39; is not a tensor&#34;
                return tensor

        def __dir__(self) -&gt; List[str]:
                dimensions = [self._subdir[Compartment.Dimensions].unpack(k)[0] for k,v in self._db.transaction[self._subdir[Compartment.Dimensions].range()]]
                tensors = [self._subdir[Compartment.Tensors].unpack(k)[0] for k,v in self._db.transaction[self._subdir[Compartment.Tensors].range()]]
                return self._subdir.list(self._db.transaction) + dimensions + tensors + object.__dir__(self)

        def __iter__(self):
                for w in shoji.io.list_workspaces(self._db.transaction, self):
                        yield w
                for t in shoji.io.list_tensors(self._db.transaction, self):
                        yield t
                for d in shoji.io.list_dimensions(self._db.transaction, self):
                        yield d

        def __contains__(self, name: str) -&gt; bool:
                entity = shoji.io.get_entity(self._db.transaction, self, name)
                if entity is not None:
                        return True
                parts = name.split(&#34;.&#34;)
                entity = shoji.io.get_entity(self._db.transaction, self, parts[0])
                if entity is None:
                        return False
                if len(parts) == 1:
                        return True
                else:
                        if isinstance(entity, shoji.WorkspaceManager):
                                return entity.__contains__(&#34;.&#34;.join(parts[1:]))
                        else:
                                raise ValueError(&#34;First part of a multi-part name must be a workspace&#34;)

        def __getattr__(self, name: str) -&gt; Union[&#34;WorkspaceManager&#34;, shoji.Dimension, shoji.Tensor]:
                if name.startswith(&#34;_&#34;):  # Jupyter calls this method with names like &#34;__wrapped__&#34; and we want to avoid a futile database roundtrip
                        return super().__getattribute__(name)
                entity = shoji.io.get_entity(self._db.transaction, self, name)
                if entity is not None:
                        return entity
                # The name could be a multi-part expression like x.y.z
                parts = name.split(&#34;.&#34;)
                entity = shoji.io.get_entity(self._db.transaction, self, parts[0])
                if entity is None:
                        return super().__getattribute__(name)
                if len(parts) == 1:
                        return entity
                else:
                        if isinstance(entity, shoji.WorkspaceManager):
                                return entity.__getattr__(&#34;.&#34;.join(parts[1:]))
                        else:
                                raise ValueError(&#34;First part of a multi-part name must be a workspace&#34;)

        def __getitem__(self, expr: Union[str, &#34;shoji.Filter&#34;, slice]) -&gt; Union[&#34;WorkspaceManager&#34;, shoji.Dimension, &#34;shoji.View&#34;, shoji.Tensor]:
                # Try to read an attribute on the object
                if isinstance(expr, str):
                        return self.__getattr__(expr)
                # Perhaps it&#39;s a view already (e.g. a slice of a dimension)
                if isinstance(expr, shoji.View):
                        return expr
                # Maybe it&#39;s a Filter, or a tuple of Filters?
                if isinstance(expr, shoji.Filter):
                        return shoji.View(self, (expr,))
                elif isinstance(expr, tuple) and isinstance(expr[0], shoji.Filter):
                        return shoji.View(self, expr)
                # Or a slice?
                if isinstance(expr, slice):
                        if expr.start is None and expr.stop is None:
                                return shoji.View(self, ())
                        else:
                                raise KeyError(&#34;Cannot slice workspace directly (use a slice on a dimension instead)&#34;)
                raise KeyError(f&#34;Invalid key &#39;{expr}&#39; (only filter expression or : allowed)&#34;)

        def __setattr__(self, name: str, value: Any) -&gt; None:
                if &#34;.&#34; in name:
                        raise AttributeError(f&#34;Invalid name &#39;{name}&#39; (names cannot contain periods (.))&#34;)
                if isinstance(value, Workspace):
                        if name in self:
                                raise AttributeError(f&#34;Cannot overwrite existing entity with new workspace {name}&#34;)
                        self._create(name)
                elif isinstance(value, shoji.Dimension):
                        # Check that the first letter is lowercase
                        if not name[0].islower():
                                raise AttributeError(&#34;Dimension name must begin with a lowercase letter&#34;)
                        shoji.io.create_dimension(self._db.transaction, self, name, value)
                elif isinstance(value, shoji.Tensor):
                        tensor = value
                        # Check that the first letter is uppercase
                        if not name[0].isupper():
                                raise AttributeError(&#34;Tensor name must begin with an uppercase letter&#34;)

                        if name in self:
                                if isinstance(self[name], shoji.Tensor):
                                        del self[name]
                                else:
                                        raise AttributeError(f&#34;Cannot create new tensor &#39;{name}&#39; because it would overwrite existing entity&#34;)
                        shoji.io.create_tensor(self._db.transaction, self, name, tensor)
                        shoji.io.initialize_tensor(self, name, tensor)
                elif isinstance(value, shoji.WorkspaceManager):
                        raise ValueError(&#34;Cannot assign WorkspaceManager object to workspace (did you mean to use Workspace object?&#34;)
                else:
                        super().__setattr__(name, value)
        
        def __setitem__(self, name: str, value: Any) -&gt; None:
                self.__setattr__(name, value)

        def __delattr__(self, name: str) -&gt; None:
                shoji.io.delete_entity(self._db.transaction, self, name)

        def __delitem__(self, name: str) -&gt; None:
                shoji.io.delete_entity(self._db.transaction, self, name)

        def _from_loom(self, f: str, verbose: bool = False) -&gt; None:
                &#34;&#34;&#34;
                Load a loom files into a workspace

                Args:
                        f                                               Filename (full path)
                        verbose                                 If true, log progress
                &#34;&#34;&#34;

                def fix_name(name, suffix, other_names):
                        if name in other_names:
                                name += &#34;_&#34; + suffix
                        name = name.capitalize()
                        if not name[0].isupper():
                                name = &#34;X_&#34; + name
                        name = name.replace(&#34;.&#34;, &#34;_&#34;)
                        return name

                dimension_names = (&#34;genes&#34;, &#34;cells&#34;)
                genes_dim = dimension_names[0]
                cells_dim = dimension_names[1]
                with loompy.connect(f, validate=False) as ds:
                        self[genes_dim] = shoji.Dimension(shape=ds.shape[0])
                        self[cells_dim] = shoji.Dimension(shape=ds.shape[1])

                        if verbose:
                                logging.info(&#34;Loading global attributes&#34;)

                        for key, val in ds.attrs.items():
                                if not isinstance(val, np.ndarray):
                                        val = np.array(val)
                                dtype = val.dtype.name
                                if dtype.startswith(&#34;str&#34;):
                                        dtype = &#34;string&#34;
                                        val = val.astype(&#34;object&#34;)
                                name = fix_name(key, &#34;global&#34;, ds.ca.keys() + ds.ra.keys() + ds.layers.keys())
                                self[name] = shoji.Tensor(&#34;string&#34; if dtype == &#34;object&#34; else dtype, val.shape, inits=val)

                        if verbose:
                                logging.info(&#34;Loading row attributes&#34;)
                        for key, vals in ds.ra.items():
                                dtype = vals.dtype.name
                                dtype = &#34;string&#34; if dtype == &#34;object&#34; else dtype
                                name = fix_name(key, genes_dim, ds.ca.keys() + ds.layers.keys() + ds.attrs.keys())
                                dims = (genes_dim, ) + vals.shape[1:]
                                self[name] = shoji.Tensor(dtype, dims, inits=ds.ra[key])

                        if verbose:
                                logging.info(&#34;Loading column attributes&#34;)
                        for key, vals in ds.ca.items():
                                dtype = ds.ca[key].dtype.name
                                dtype = &#34;string&#34; if dtype == &#34;object&#34; else dtype
                                name = fix_name(key, cells_dim, ds.ra.keys() + ds.layers.keys() + ds.attrs.keys())
                                dims = (cells_dim,) + vals.shape[1:]
                                self[name] = shoji.Tensor(dtype, dims, inits=ds.ca[key])

                        if verbose:
                                logging.info(&#34;Loading layers&#34;)
                        u = ds.layers[&#34;unspliced&#34;][:, :].T.astype(&#34;uint16&#34;)
                        s = ds.layers[&#34;spliced&#34;][:, :].T.astype(&#34;uint16&#34;)
                        a = ds.layers[&#34;ambiguous&#34;][:, :].T.astype(&#34;uint16&#34;)
                        self[&#34;Unspliced&#34;] = shoji.Tensor(&#34;uint16&#34;, (cells_dim, genes_dim), inits=u)
                        self[&#34;Spliced&#34;] = shoji.Tensor(&#34;uint16&#34;, (cells_dim, genes_dim), inits=s)
                        self[&#34;Expression&#34;] = shoji.Tensor(&#34;uint16&#34;, (cells_dim, genes_dim), inits=u + s + a)
                        
        def __repr__(self) -&gt; str:
                subdirs = self._workspaces()
                dimensions = [self._subdir[Compartment.Dimensions].unpack(k.key)[0] for k in self._db.transaction[self._subdir[Compartment.Dimensions].range()]]
                tensors = [self._subdir[Compartment.Tensors].unpack(k.key)[0] for k in self._db.transaction[self._subdir[Compartment.Tensors].range()]]
                s = f&#34;Workspace with {len(subdirs)} workspaces, {len(dimensions)} dimensions and {len(tensors)} tensors:&#34;
                for sub in subdirs:
                        s += f&#34;\n  {sub} &lt;Workspace&gt;&#34; 
                for dname in dimensions:
                        s += f&#34;\n  {dname} {self[dname]}&#34;
                for tname in tensors:
                        s += f&#34;\n  {tname} {self[tname]}&#34;
                return s

        def _repr_html_(self):
                if len(self._path) == 0:
                        s = f&#34;&lt;h4&gt;(root) (shoji.Workspace)&lt;/h4&gt;&#34;
                else:
                        s = f&#34;&lt;h4&gt;{self._name} (shoji.Workspace)&lt;/h4&gt;&#34;
                
                subdirs = self._workspaces()
                if len(subdirs) &gt; 0:
                        s += f&#34;&lt;h5&gt;Sub-workspaces&lt;/h5&gt;&#34;
                        s += &#34;&lt;table&gt;&lt;tr&gt;&lt;th&gt;&lt;/th&gt;&lt;th&gt;Contents&lt;/th&gt;&lt;/tr&gt;&#34;
                        for wsname in subdirs:
                                ws = self[wsname]
                                s += &#34;&lt;tr&gt;&#34;
                                n_subdirs = len(ws._workspaces())
                                n_dimensions = len(ws._dimensions())
                                n_tensors = len(ws._tensors())
                                s += f&#34;&lt;td align=&#39;left&#39;&gt;&lt;strong&gt;{ws._name}&lt;/strong&gt;&lt;/td&gt;&lt;td&gt;{n_subdirs} workspaces, {n_dimensions} dimensions, {n_tensors} tensors&lt;/td&gt;&#34;
                                s += &#34;&lt;/tr&gt;&#34;
                        s += &#34;&lt;/table&gt;&#34;
        
                dimensions = self._dimensions()
                if len(dimensions) &gt; 0:
                        s += f&#34;&lt;h5&gt;Dimensions&lt;/h5&gt;&#34;
                        s += &#34;&lt;table&gt;&lt;tr&gt;&lt;th&gt;&lt;/th&gt;&lt;th&gt;shape&lt;/th&gt;&lt;th&gt;length&lt;/th&gt;&lt;/tr&gt;&#34;
                        for dname in dimensions:
                                dim = self[dname]
                                s += &#34;&lt;tr&gt;&#34;
                                s += f&#34;&lt;td align=&#39;left&#39;&gt;&lt;strong&gt;{dim.name}&lt;/strong&gt;&lt;/td&gt;&#34;
                                s += f&#34;&lt;td&gt;{dim.shape:,}&lt;/td&gt;&#34; if dim.shape is not None else &#34;&lt;td&gt;None&lt;/td&gt;&#34;
                                s += f&#34;&lt;td&gt;{dim.length:,}&lt;/td&gt;&#34;
                                s += &#34;&lt;/tr&gt;&#34;
                        s += &#34;&lt;/table&gt;&#34;

                tensors = self._tensors()
                if len(tensors) &gt; 0:
                        s += f&#34;&lt;h5&gt;Tensors&lt;/h5&gt;&#34;
                        s += &#34;&lt;table&gt;&lt;tr&gt;&lt;th&gt;&lt;/th&gt;&lt;th&gt;dtype&lt;/th&gt;&lt;th&gt;rank&lt;/th&gt;&lt;th&gt;dims&lt;/th&gt;&lt;th&gt;shape&lt;/th&gt;&lt;th&gt;(values)&lt;/th&gt;&lt;/tr&gt;&#34;
                        for tname in tensors:
                                t = self[tname]
                                s += &#34;&lt;tr&gt;&#34;
                                s += f&#34;&lt;td align=&#39;left&#39;&gt;&lt;strong&gt;{t.name}&lt;/strong&gt;&lt;/td&gt;&#34;
                                s += f&#34;&lt;td align=&#39;left&#39;&gt;{t.dtype}&lt;/td&gt;&#34;
                                s += f&#34;&lt;td align=&#39;left&#39;&gt;{t.rank}&lt;/td&gt;&#34;
                                if t.rank &gt; 0:
                                        s += &#34;&lt;td&gt;&#34; + &#34; ✕ &#34;.join([(str(s) if s is not None else &#34;__&#34;) for s in t.dims]) + &#34;&lt;/td&gt;&#34;
                                        shps = []
                                        for i, shp in enumerate(t.shape):
                                                # if t.dims[i] is None:
                                                #       shps.append(&#34;__&#34;)
                                                # elif isinstance(t.dims[i], str) and self[t.dims[i]].shape is None:
                                                #       shps.append(&#34;__&#34;)
                                                if i == 0 and t.jagged:
                                                        shps.append(&#34;__&#34;)
                                                else:
                                                        shps.append(&#34;{:,}&#34;.format(shp))
                                        s += &#34;&lt;td&gt;&#34; + &#34; ✕ &#34;.join(shps) + &#34;&lt;/td&gt;&#34;
                                else:
                                        s += &#34;&lt;td&gt;()&lt;/td&gt;&#34;
                                        s += &#34;&lt;td&gt;()&lt;/td&gt;&#34;
                                s += f&#34;&lt;td&gt;{t._quick_look()}&lt;/td&gt;&#34;
                                s += &#34;&lt;/tr&gt;&#34;
                        s += &#34;&lt;/table&gt;&#34;
                return s

        def _import(self, f: str):
                &#34;&#34;&#34;
                Import a previously exported workspace

                Args:
                        f               The file name (full path)
                &#34;&#34;&#34;

                h5 = h5py.File(f, &#34;r&#34;)
                group = h5.require_group(&#34;shoji&#34;)
                for att in group.attrs:
                        if att.startswith(&#34;Dimension$&#34;):
                                shape = group.attrs[att]
                                if shape == -1:
                                        shape = None
                                self[att[10:]] = shoji.Dimension(shape=shape)

                for tname in group:
                        if tname.startswith(&#34;Tensor$&#34;):
                                data = group[tname][:]
                                tensor = pickle.loads(decode(group[tname], &#34;base64&#34;))
                                if tensor.dtype == &#34;string&#34;:
                                        data = data.astype(&#34;object&#34;)
                                tname = tname[7:]
                                self[tname] = shoji.Tensor(tensor.dtype, tensor.dims, chunks=tensor.chunks, jagged=tensor.jagged, inits=data)

                h5.close()

        def _export(self, f: str):
                &#34;&#34;&#34;
                Export the workspace to an HDF5 file

                Args:
                        f                       The file name (full path)

                Remarks:
                        If the file does not exist, it will be created
                &#34;&#34;&#34;
                if os.path.exists(f):
                        os.remove(f)
                with h5py.File(f, &#34;w&#34;) as h5:
                        group = h5.require_group(&#34;shoji&#34;)

                        for dname in self._dimensions():
                                dim = self._get_dimension(dname)
                                group.attrs[&#34;Dimension$&#34; + dname] = (dim.shape if dim.shape is not None else -1, dim.length)

                        for tname in self._tensors():
                                tensor = self._get_tensor(tname)
                                if tensor.jagged:
                                        logging.warning(f&#34;Skipping &#39;{tname}&#39; because jagged tensors are not yet supported for export&#34;)
                                        continue
                                group.attrs[&#34;Tensor$&#34; + tname] = encode(pickle.dumps(tensor, protocol=4), &#34;base-64&#34;)
                                
                                dtype = tensor.dtype
                                if tensor.dtype == &#34;string&#34;:
                                        dtype = h5py.special_dtype(vlen=str)
                                
                                if tensor.rank == 0:
                                        ds = group.create_dataset(tname, shape=tensor.shape, data=self[tname][:], dtype=dtype, compression=None)
                                else:
                                        ds = group.create_dataset(tname, shape=tensor.shape, dtype=dtype, compression=&#34;gzip&#34;)
                                        BATCH_SIZE = tensor.chunks[0] * 100
                                        for ix in trange(0, tensor.shape[0], BATCH_SIZE, desc=tname):
                                                end = min(ix + BATCH_SIZE, tensor.shape[0])
                                                data: np.ndarray = self[tname][ix:end]
                                                try:
                                                        ds[ix: end] = data
                                                except OSError as e:
                                                        print(tname, ix, dtype, tensor.dtype, self[tname][ix:end].dtype)
                                                        raise e

def create_workspace(db: &#34;WorkspaceManager&#34;, path: str) -&gt; &#34;WorkspaceManager&#34;:
        &#34;&#34;&#34;
        Create a new workspace with the given path, unless it already exists

        Args:
                db:                     The root workspace from which the path should begin
                path:           The path, relative to the root
        &#34;&#34;&#34;

        return db._create(tuple(path.split(&#34;.&#34;)))</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="shoji.workspace.create_workspace"><code class="name flex">
<span>def <span class="ident">create_workspace</span></span>(<span>db: <a title="shoji.workspace.WorkspaceManager" href="#shoji.workspace.WorkspaceManager">WorkspaceManager</a>, path: str) ‑> <a title="shoji.workspace.WorkspaceManager" href="#shoji.workspace.WorkspaceManager">WorkspaceManager</a></span>
</code></dt>
<dd>
<div class="desc"><p>Create a new workspace with the given path, unless it already exists</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>db</code></strong></dt>
<dd>
<pre><code>            The root workspace from which the path should begin
</code></pre>
</dd>
<dt><strong><code>path</code></strong></dt>
<dd>
<pre><code>  The path, relative to the root
</code></pre>
</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_workspace(db: &#34;WorkspaceManager&#34;, path: str) -&gt; &#34;WorkspaceManager&#34;:
        &#34;&#34;&#34;
        Create a new workspace with the given path, unless it already exists

        Args:
                db:                     The root workspace from which the path should begin
                path:           The path, relative to the root
        &#34;&#34;&#34;

        return db._create(tuple(path.split(&#34;.&#34;)))</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="shoji.workspace.Workspace"><code class="flex name class">
<span>class <span class="ident">Workspace</span></span>
</code></dt>
<dd>
<div class="desc"><p>Class representing a new Workspace. Use this to create new workspaces in Shoji.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Workspace:
        &#34;&#34;&#34;
        Class representing a new Workspace. Use this to create new workspaces in Shoji.
        &#34;&#34;&#34;
        def __init__(self) -&gt; None:
                pass</code></pre>
</details>
</dd>
<dt id="shoji.workspace.WorkspaceManager"><code class="flex name class">
<span>class <span class="ident">WorkspaceManager</span></span>
<span>(</span><span>db: fdb.impl.Database, subdir: fdb.directory_impl.DirectorySubspace, path: Union[Tuple, Tuple[str, ...]])</span>
</code></dt>
<dd>
<div class="desc"><p>Class for managing workspaces. You should not create WorkspaceManager objects yourself.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class WorkspaceManager:
        &#34;&#34;&#34;
        Class for managing workspaces. You should not create WorkspaceManager objects yourself.
        &#34;&#34;&#34;
        def __init__(self, db: fdb.impl.Database, subdir: fdb.directory_impl.DirectorySubspace, path: Union[Tuple, Tuple[str, ...]]) -&gt; None:
                self._db = db
                self._subdir = subdir
                self._path = path
                self._name: str = &#34;&#34;

        def _move_to(self, new_path: Union[str, Tuple[str, ...]]) -&gt; None:
                if isinstance(new_path, str):
                        new_path = tuple(new_path.split(&#34;.&#34;))
                self._subdir = self._subdir.move_to(self._db.transaction, (&#34;shoji&#34;,) + new_path)
                self._path = new_path
                
        def _create(self, path: Union[str, Tuple[str, ...]]) -&gt; &#34;WorkspaceManager&#34;:
                if not isinstance(path, tuple):
                        path = (path,)
                if self._subdir.exists(self._db.transaction, path):
                        raise IOError(f&#34;Workspace &#39;{&#39;/&#39;.join(path)}&#39; already exists&#34;)
                subdir = self._subdir.create(self._db.transaction, path)
                return WorkspaceManager(self._db.transaction, subdir, self._path + path)

        def _workspaces(self) -&gt; List[str]:
                return self._subdir.list(self._db.transaction)

        def _get_workspace(self, name: str) -&gt; &#34;WorkspaceManager&#34;:
                ws = self[name]
                assert isinstance(ws, shoji.WorkspaceManager), f&#34;&#39;{name}&#39; is not a workspace&#34;
                return ws

        def _dimensions(self) -&gt; List[str]:
                return [self._subdir[Compartment.Dimensions].unpack(k.key)[0] for k in self._db.transaction[self._subdir[Compartment.Dimensions].range()]]

        def _get_dimension(self, name: str) -&gt; shoji.Dimension:
                dim = self[name]
                assert isinstance(dim, shoji.Dimension), f&#34;&#39;{name}&#39; is not a dimension&#34;
                return dim

        def _tensors(self, include_not_ready: bool = False) -&gt; List[str]:
                names = [self._subdir[Compartment.Tensors].unpack(k.key)[0] for k in self._db.transaction[self._subdir[Compartment.Tensors].range()]]
                if include_not_ready:
                        return names
                return [name for name in names if shoji.io.get_tensor(self._db.transaction, self, name) is not None]

        def _get_tensor(self, name: str, include_initializing: bool = False) -&gt; shoji.Tensor:
                tensor = shoji.io.get_tensor(self._db.transaction, self, name, include_initializing=include_initializing)
                assert isinstance(tensor, shoji.Tensor), f&#34;&#39;{name}&#39; is not a tensor&#34;
                return tensor

        def __dir__(self) -&gt; List[str]:
                dimensions = [self._subdir[Compartment.Dimensions].unpack(k)[0] for k,v in self._db.transaction[self._subdir[Compartment.Dimensions].range()]]
                tensors = [self._subdir[Compartment.Tensors].unpack(k)[0] for k,v in self._db.transaction[self._subdir[Compartment.Tensors].range()]]
                return self._subdir.list(self._db.transaction) + dimensions + tensors + object.__dir__(self)

        def __iter__(self):
                for w in shoji.io.list_workspaces(self._db.transaction, self):
                        yield w
                for t in shoji.io.list_tensors(self._db.transaction, self):
                        yield t
                for d in shoji.io.list_dimensions(self._db.transaction, self):
                        yield d

        def __contains__(self, name: str) -&gt; bool:
                entity = shoji.io.get_entity(self._db.transaction, self, name)
                if entity is not None:
                        return True
                parts = name.split(&#34;.&#34;)
                entity = shoji.io.get_entity(self._db.transaction, self, parts[0])
                if entity is None:
                        return False
                if len(parts) == 1:
                        return True
                else:
                        if isinstance(entity, shoji.WorkspaceManager):
                                return entity.__contains__(&#34;.&#34;.join(parts[1:]))
                        else:
                                raise ValueError(&#34;First part of a multi-part name must be a workspace&#34;)

        def __getattr__(self, name: str) -&gt; Union[&#34;WorkspaceManager&#34;, shoji.Dimension, shoji.Tensor]:
                if name.startswith(&#34;_&#34;):  # Jupyter calls this method with names like &#34;__wrapped__&#34; and we want to avoid a futile database roundtrip
                        return super().__getattribute__(name)
                entity = shoji.io.get_entity(self._db.transaction, self, name)
                if entity is not None:
                        return entity
                # The name could be a multi-part expression like x.y.z
                parts = name.split(&#34;.&#34;)
                entity = shoji.io.get_entity(self._db.transaction, self, parts[0])
                if entity is None:
                        return super().__getattribute__(name)
                if len(parts) == 1:
                        return entity
                else:
                        if isinstance(entity, shoji.WorkspaceManager):
                                return entity.__getattr__(&#34;.&#34;.join(parts[1:]))
                        else:
                                raise ValueError(&#34;First part of a multi-part name must be a workspace&#34;)

        def __getitem__(self, expr: Union[str, &#34;shoji.Filter&#34;, slice]) -&gt; Union[&#34;WorkspaceManager&#34;, shoji.Dimension, &#34;shoji.View&#34;, shoji.Tensor]:
                # Try to read an attribute on the object
                if isinstance(expr, str):
                        return self.__getattr__(expr)
                # Perhaps it&#39;s a view already (e.g. a slice of a dimension)
                if isinstance(expr, shoji.View):
                        return expr
                # Maybe it&#39;s a Filter, or a tuple of Filters?
                if isinstance(expr, shoji.Filter):
                        return shoji.View(self, (expr,))
                elif isinstance(expr, tuple) and isinstance(expr[0], shoji.Filter):
                        return shoji.View(self, expr)
                # Or a slice?
                if isinstance(expr, slice):
                        if expr.start is None and expr.stop is None:
                                return shoji.View(self, ())
                        else:
                                raise KeyError(&#34;Cannot slice workspace directly (use a slice on a dimension instead)&#34;)
                raise KeyError(f&#34;Invalid key &#39;{expr}&#39; (only filter expression or : allowed)&#34;)

        def __setattr__(self, name: str, value: Any) -&gt; None:
                if &#34;.&#34; in name:
                        raise AttributeError(f&#34;Invalid name &#39;{name}&#39; (names cannot contain periods (.))&#34;)
                if isinstance(value, Workspace):
                        if name in self:
                                raise AttributeError(f&#34;Cannot overwrite existing entity with new workspace {name}&#34;)
                        self._create(name)
                elif isinstance(value, shoji.Dimension):
                        # Check that the first letter is lowercase
                        if not name[0].islower():
                                raise AttributeError(&#34;Dimension name must begin with a lowercase letter&#34;)
                        shoji.io.create_dimension(self._db.transaction, self, name, value)
                elif isinstance(value, shoji.Tensor):
                        tensor = value
                        # Check that the first letter is uppercase
                        if not name[0].isupper():
                                raise AttributeError(&#34;Tensor name must begin with an uppercase letter&#34;)

                        if name in self:
                                if isinstance(self[name], shoji.Tensor):
                                        del self[name]
                                else:
                                        raise AttributeError(f&#34;Cannot create new tensor &#39;{name}&#39; because it would overwrite existing entity&#34;)
                        shoji.io.create_tensor(self._db.transaction, self, name, tensor)
                        shoji.io.initialize_tensor(self, name, tensor)
                elif isinstance(value, shoji.WorkspaceManager):
                        raise ValueError(&#34;Cannot assign WorkspaceManager object to workspace (did you mean to use Workspace object?&#34;)
                else:
                        super().__setattr__(name, value)
        
        def __setitem__(self, name: str, value: Any) -&gt; None:
                self.__setattr__(name, value)

        def __delattr__(self, name: str) -&gt; None:
                shoji.io.delete_entity(self._db.transaction, self, name)

        def __delitem__(self, name: str) -&gt; None:
                shoji.io.delete_entity(self._db.transaction, self, name)

        def _from_loom(self, f: str, verbose: bool = False) -&gt; None:
                &#34;&#34;&#34;
                Load a loom files into a workspace

                Args:
                        f                                               Filename (full path)
                        verbose                                 If true, log progress
                &#34;&#34;&#34;

                def fix_name(name, suffix, other_names):
                        if name in other_names:
                                name += &#34;_&#34; + suffix
                        name = name.capitalize()
                        if not name[0].isupper():
                                name = &#34;X_&#34; + name
                        name = name.replace(&#34;.&#34;, &#34;_&#34;)
                        return name

                dimension_names = (&#34;genes&#34;, &#34;cells&#34;)
                genes_dim = dimension_names[0]
                cells_dim = dimension_names[1]
                with loompy.connect(f, validate=False) as ds:
                        self[genes_dim] = shoji.Dimension(shape=ds.shape[0])
                        self[cells_dim] = shoji.Dimension(shape=ds.shape[1])

                        if verbose:
                                logging.info(&#34;Loading global attributes&#34;)

                        for key, val in ds.attrs.items():
                                if not isinstance(val, np.ndarray):
                                        val = np.array(val)
                                dtype = val.dtype.name
                                if dtype.startswith(&#34;str&#34;):
                                        dtype = &#34;string&#34;
                                        val = val.astype(&#34;object&#34;)
                                name = fix_name(key, &#34;global&#34;, ds.ca.keys() + ds.ra.keys() + ds.layers.keys())
                                self[name] = shoji.Tensor(&#34;string&#34; if dtype == &#34;object&#34; else dtype, val.shape, inits=val)

                        if verbose:
                                logging.info(&#34;Loading row attributes&#34;)
                        for key, vals in ds.ra.items():
                                dtype = vals.dtype.name
                                dtype = &#34;string&#34; if dtype == &#34;object&#34; else dtype
                                name = fix_name(key, genes_dim, ds.ca.keys() + ds.layers.keys() + ds.attrs.keys())
                                dims = (genes_dim, ) + vals.shape[1:]
                                self[name] = shoji.Tensor(dtype, dims, inits=ds.ra[key])

                        if verbose:
                                logging.info(&#34;Loading column attributes&#34;)
                        for key, vals in ds.ca.items():
                                dtype = ds.ca[key].dtype.name
                                dtype = &#34;string&#34; if dtype == &#34;object&#34; else dtype
                                name = fix_name(key, cells_dim, ds.ra.keys() + ds.layers.keys() + ds.attrs.keys())
                                dims = (cells_dim,) + vals.shape[1:]
                                self[name] = shoji.Tensor(dtype, dims, inits=ds.ca[key])

                        if verbose:
                                logging.info(&#34;Loading layers&#34;)
                        u = ds.layers[&#34;unspliced&#34;][:, :].T.astype(&#34;uint16&#34;)
                        s = ds.layers[&#34;spliced&#34;][:, :].T.astype(&#34;uint16&#34;)
                        a = ds.layers[&#34;ambiguous&#34;][:, :].T.astype(&#34;uint16&#34;)
                        self[&#34;Unspliced&#34;] = shoji.Tensor(&#34;uint16&#34;, (cells_dim, genes_dim), inits=u)
                        self[&#34;Spliced&#34;] = shoji.Tensor(&#34;uint16&#34;, (cells_dim, genes_dim), inits=s)
                        self[&#34;Expression&#34;] = shoji.Tensor(&#34;uint16&#34;, (cells_dim, genes_dim), inits=u + s + a)
                        
        def __repr__(self) -&gt; str:
                subdirs = self._workspaces()
                dimensions = [self._subdir[Compartment.Dimensions].unpack(k.key)[0] for k in self._db.transaction[self._subdir[Compartment.Dimensions].range()]]
                tensors = [self._subdir[Compartment.Tensors].unpack(k.key)[0] for k in self._db.transaction[self._subdir[Compartment.Tensors].range()]]
                s = f&#34;Workspace with {len(subdirs)} workspaces, {len(dimensions)} dimensions and {len(tensors)} tensors:&#34;
                for sub in subdirs:
                        s += f&#34;\n  {sub} &lt;Workspace&gt;&#34; 
                for dname in dimensions:
                        s += f&#34;\n  {dname} {self[dname]}&#34;
                for tname in tensors:
                        s += f&#34;\n  {tname} {self[tname]}&#34;
                return s

        def _repr_html_(self):
                if len(self._path) == 0:
                        s = f&#34;&lt;h4&gt;(root) (shoji.Workspace)&lt;/h4&gt;&#34;
                else:
                        s = f&#34;&lt;h4&gt;{self._name} (shoji.Workspace)&lt;/h4&gt;&#34;
                
                subdirs = self._workspaces()
                if len(subdirs) &gt; 0:
                        s += f&#34;&lt;h5&gt;Sub-workspaces&lt;/h5&gt;&#34;
                        s += &#34;&lt;table&gt;&lt;tr&gt;&lt;th&gt;&lt;/th&gt;&lt;th&gt;Contents&lt;/th&gt;&lt;/tr&gt;&#34;
                        for wsname in subdirs:
                                ws = self[wsname]
                                s += &#34;&lt;tr&gt;&#34;
                                n_subdirs = len(ws._workspaces())
                                n_dimensions = len(ws._dimensions())
                                n_tensors = len(ws._tensors())
                                s += f&#34;&lt;td align=&#39;left&#39;&gt;&lt;strong&gt;{ws._name}&lt;/strong&gt;&lt;/td&gt;&lt;td&gt;{n_subdirs} workspaces, {n_dimensions} dimensions, {n_tensors} tensors&lt;/td&gt;&#34;
                                s += &#34;&lt;/tr&gt;&#34;
                        s += &#34;&lt;/table&gt;&#34;
        
                dimensions = self._dimensions()
                if len(dimensions) &gt; 0:
                        s += f&#34;&lt;h5&gt;Dimensions&lt;/h5&gt;&#34;
                        s += &#34;&lt;table&gt;&lt;tr&gt;&lt;th&gt;&lt;/th&gt;&lt;th&gt;shape&lt;/th&gt;&lt;th&gt;length&lt;/th&gt;&lt;/tr&gt;&#34;
                        for dname in dimensions:
                                dim = self[dname]
                                s += &#34;&lt;tr&gt;&#34;
                                s += f&#34;&lt;td align=&#39;left&#39;&gt;&lt;strong&gt;{dim.name}&lt;/strong&gt;&lt;/td&gt;&#34;
                                s += f&#34;&lt;td&gt;{dim.shape:,}&lt;/td&gt;&#34; if dim.shape is not None else &#34;&lt;td&gt;None&lt;/td&gt;&#34;
                                s += f&#34;&lt;td&gt;{dim.length:,}&lt;/td&gt;&#34;
                                s += &#34;&lt;/tr&gt;&#34;
                        s += &#34;&lt;/table&gt;&#34;

                tensors = self._tensors()
                if len(tensors) &gt; 0:
                        s += f&#34;&lt;h5&gt;Tensors&lt;/h5&gt;&#34;
                        s += &#34;&lt;table&gt;&lt;tr&gt;&lt;th&gt;&lt;/th&gt;&lt;th&gt;dtype&lt;/th&gt;&lt;th&gt;rank&lt;/th&gt;&lt;th&gt;dims&lt;/th&gt;&lt;th&gt;shape&lt;/th&gt;&lt;th&gt;(values)&lt;/th&gt;&lt;/tr&gt;&#34;
                        for tname in tensors:
                                t = self[tname]
                                s += &#34;&lt;tr&gt;&#34;
                                s += f&#34;&lt;td align=&#39;left&#39;&gt;&lt;strong&gt;{t.name}&lt;/strong&gt;&lt;/td&gt;&#34;
                                s += f&#34;&lt;td align=&#39;left&#39;&gt;{t.dtype}&lt;/td&gt;&#34;
                                s += f&#34;&lt;td align=&#39;left&#39;&gt;{t.rank}&lt;/td&gt;&#34;
                                if t.rank &gt; 0:
                                        s += &#34;&lt;td&gt;&#34; + &#34; ✕ &#34;.join([(str(s) if s is not None else &#34;__&#34;) for s in t.dims]) + &#34;&lt;/td&gt;&#34;
                                        shps = []
                                        for i, shp in enumerate(t.shape):
                                                # if t.dims[i] is None:
                                                #       shps.append(&#34;__&#34;)
                                                # elif isinstance(t.dims[i], str) and self[t.dims[i]].shape is None:
                                                #       shps.append(&#34;__&#34;)
                                                if i == 0 and t.jagged:
                                                        shps.append(&#34;__&#34;)
                                                else:
                                                        shps.append(&#34;{:,}&#34;.format(shp))
                                        s += &#34;&lt;td&gt;&#34; + &#34; ✕ &#34;.join(shps) + &#34;&lt;/td&gt;&#34;
                                else:
                                        s += &#34;&lt;td&gt;()&lt;/td&gt;&#34;
                                        s += &#34;&lt;td&gt;()&lt;/td&gt;&#34;
                                s += f&#34;&lt;td&gt;{t._quick_look()}&lt;/td&gt;&#34;
                                s += &#34;&lt;/tr&gt;&#34;
                        s += &#34;&lt;/table&gt;&#34;
                return s

        def _import(self, f: str):
                &#34;&#34;&#34;
                Import a previously exported workspace

                Args:
                        f               The file name (full path)
                &#34;&#34;&#34;

                h5 = h5py.File(f, &#34;r&#34;)
                group = h5.require_group(&#34;shoji&#34;)
                for att in group.attrs:
                        if att.startswith(&#34;Dimension$&#34;):
                                shape = group.attrs[att]
                                if shape == -1:
                                        shape = None
                                self[att[10:]] = shoji.Dimension(shape=shape)

                for tname in group:
                        if tname.startswith(&#34;Tensor$&#34;):
                                data = group[tname][:]
                                tensor = pickle.loads(decode(group[tname], &#34;base64&#34;))
                                if tensor.dtype == &#34;string&#34;:
                                        data = data.astype(&#34;object&#34;)
                                tname = tname[7:]
                                self[tname] = shoji.Tensor(tensor.dtype, tensor.dims, chunks=tensor.chunks, jagged=tensor.jagged, inits=data)

                h5.close()

        def _export(self, f: str):
                &#34;&#34;&#34;
                Export the workspace to an HDF5 file

                Args:
                        f                       The file name (full path)

                Remarks:
                        If the file does not exist, it will be created
                &#34;&#34;&#34;
                if os.path.exists(f):
                        os.remove(f)
                with h5py.File(f, &#34;w&#34;) as h5:
                        group = h5.require_group(&#34;shoji&#34;)

                        for dname in self._dimensions():
                                dim = self._get_dimension(dname)
                                group.attrs[&#34;Dimension$&#34; + dname] = (dim.shape if dim.shape is not None else -1, dim.length)

                        for tname in self._tensors():
                                tensor = self._get_tensor(tname)
                                if tensor.jagged:
                                        logging.warning(f&#34;Skipping &#39;{tname}&#39; because jagged tensors are not yet supported for export&#34;)
                                        continue
                                group.attrs[&#34;Tensor$&#34; + tname] = encode(pickle.dumps(tensor, protocol=4), &#34;base-64&#34;)
                                
                                dtype = tensor.dtype
                                if tensor.dtype == &#34;string&#34;:
                                        dtype = h5py.special_dtype(vlen=str)
                                
                                if tensor.rank == 0:
                                        ds = group.create_dataset(tname, shape=tensor.shape, data=self[tname][:], dtype=dtype, compression=None)
                                else:
                                        ds = group.create_dataset(tname, shape=tensor.shape, dtype=dtype, compression=&#34;gzip&#34;)
                                        BATCH_SIZE = tensor.chunks[0] * 100
                                        for ix in trange(0, tensor.shape[0], BATCH_SIZE, desc=tname):
                                                end = min(ix + BATCH_SIZE, tensor.shape[0])
                                                data: np.ndarray = self[tname][ix:end]
                                                try:
                                                        ds[ix: end] = data
                                                except OSError as e:
                                                        print(tname, ix, dtype, tensor.dtype, self[tname][ix:end].dtype)
                                                        raise e</code></pre>
</details>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul>
<li><a href="#relationships">Relationships</a></li>
<li><a href="#constraints">Constraints</a></li>
<li><a href="#managing-workspaces">Managing workspaces</a></li>
</ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="shoji" href="index.html">shoji</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="shoji.workspace.create_workspace" href="#shoji.workspace.create_workspace">create_workspace</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="shoji.workspace.Workspace" href="#shoji.workspace.Workspace">Workspace</a></code></h4>
</li>
<li>
<h4><code><a title="shoji.workspace.WorkspaceManager" href="#shoji.workspace.WorkspaceManager">WorkspaceManager</a></code></h4>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.8.4</a>.</p>
</footer>
</body>
</html>